/**
 * Autogenerated by Thrift Compiler (0.9.2)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#include "tn_package_name_test_types.h"
static void 
tn_package_name_structb_destroy(tn_object_t *object)
{
  tn_package_name_structb_t *self = (tn_package_name_structb_t*) object;
  if (self->strprop != NULL) {
    tn_object_destroy(self->strprop);
    self->strprop = NULL;
  }
  if (self->v5 != NULL) {
    tn_object_destroy(self->v5);
    self->v5 = NULL;
  }
  tn_free(self);
}

static void 
tn_package_name_structb_reset(tn_object_t *object)
{
  tn_package_name_structb_t *self = (tn_package_name_structb_t*) object;
  if( self->strprop != NULL ) {
    tn_object_reset(self->strprop);
  }
  self->has_v1 = false;
  self->v1 = 0;
  self->has_v2 = false;
  self->v2 = 0;
  self->has_v3 = false;
  self->v3 = 0;
  self->has_v4 = false;
  self->v4 = 0;
  if( self->v5 != NULL ) {
    tn_object_reset(self->v5);
  }
}

/* reads a structb object */
static size_t
tn_package_name_structb_read (void *data, tn_protocol_t *protocol, tn_transport_t *transport, tn_error_t *error)
{
  int32_t size = 0;
  size_t ret = 0;
  tn_type_t ftype;
  int16_t fid;
  tn_package_name_structb_t *self = (tn_package_name_structb_t*) data;
  tn_package_name_structb_reset((tn_object_t*) self);
  return_if_fail_or_inc(ret, protocol->tn_read_struct_begin(protocol, transport, error));
  while (1) {
    return_if_fail_or_inc(ret, protocol->tn_read_field_begin(protocol, transport, NULL, &ftype, &fid, error));
    if( ftype == T_STOP ) {
      break;
    }
    switch( fid ) {
      case 1:
        if (ftype == T_STRING) {
          return_if_fail_or_inc(ret, protocol->tn_read_string_begin(protocol, transport, &size, error));
          if( self->strprop == NULL ) { 
            return_if_fail(ret, self->strprop = tn_buffer_create(size, error));
          }
          return_if_fail_or_inc(ret, protocol->tn_read_string(protocol, transport, self->strprop, size, error));
          return_if_fail_or_inc(ret, protocol->tn_read_string_end(protocol, transport, error));
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 2:
        if (ftype == T_BYTE) {
          return_if_fail_or_inc(ret, protocol->tn_read_byte(protocol, transport, &self->v1, error));
          self->has_v1 = true;
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 3:
        if (ftype == T_BYTE) {
          return_if_fail_or_inc(ret, protocol->tn_read_byte(protocol, transport, &self->v2, error));
          self->has_v2 = true;
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 4:
        if (ftype == T_BYTE) {
          return_if_fail_or_inc(ret, protocol->tn_read_byte(protocol, transport, &self->v3, error));
          self->has_v3 = true;
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 5:
        if (ftype == T_I32) {
          return_if_fail_or_inc(ret, protocol->tn_read_int32(protocol, transport, &self->v4, error));
          self->has_v4 = true;
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 6:
        if (ftype == T_STRING) {
          return_if_fail_or_inc(ret, protocol->tn_read_string_begin(protocol, transport, &size, error));
          if( self->v5 == NULL ) { 
            return_if_fail(ret, self->v5 = tn_buffer_create(size, error));
          }
          return_if_fail_or_inc(ret, protocol->tn_read_string(protocol, transport, self->v5, size, error));
          return_if_fail_or_inc(ret, protocol->tn_read_string_end(protocol, transport, error));
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      default:
        return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        break;
    }
    return_if_fail_or_inc(ret, protocol->tn_read_field_end(protocol, transport, error));
  }
  return_if_fail_or_inc(ret, protocol->tn_read_struct_end(protocol, transport, error));
  return ret;
}

static size_t
tn_package_name_structb_write (void *data, tn_protocol_t *protocol, tn_transport_t *transport, tn_error_t *error)
{
  size_t ret = 0;

  tn_package_name_structb_t *self = (tn_package_name_structb_t*) data;
  return_if_fail_or_inc(ret, protocol->tn_write_struct_begin(protocol, transport, data, error));
  
  if( self->strprop != NULL ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "strprop", T_STRING, 1, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string_begin(protocol, transport, self->strprop->pos, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string(protocol, transport, self->strprop, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string_end(protocol, transport, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->has_v1 ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "v1", T_BYTE, 2, error));
    return_if_fail_or_inc(ret, protocol->tn_write_byte(protocol, transport, self->v1, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->has_v2 ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "v2", T_BYTE, 3, error));
    return_if_fail_or_inc(ret, protocol->tn_write_byte(protocol, transport, self->v2, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->has_v3 ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "v3", T_BYTE, 4, error));
    return_if_fail_or_inc(ret, protocol->tn_write_byte(protocol, transport, self->v3, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->has_v4 ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "v4", T_I32, 5, error));
    return_if_fail_or_inc(ret, protocol->tn_write_int32(protocol, transport, self->v4, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->v5 != NULL ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "v5", T_STRING, 6, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string_begin(protocol, transport, self->v5->pos, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string(protocol, transport, self->v5, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string_end(protocol, transport, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  return_if_fail_or_inc(ret, protocol->tn_write_field_stop (protocol, transport, error));
  return_if_fail_or_inc(ret, protocol->tn_write_struct_end (protocol, transport, error));
  return ret;
}

tn_package_name_structb_t* 
tn_package_name_structb_init (tn_package_name_structb_t *self)
{
  self->parent.parent.tn_destroy = &tn_package_name_structb_destroy;
  self->parent.parent.tn_reset = &tn_package_name_structb_reset;
  self->parent.tn_write = &tn_package_name_structb_write;
  self->parent.tn_read = &tn_package_name_structb_read;
  tn_package_name_structb_reset((tn_object_t*) self);
  return self;
}

tn_package_name_structb_t* 
tn_package_name_structb_create(tn_error_t *error)
{
  tn_package_name_structb_t *object = NULL;
  return_if_fail(object, object = tn_alloc(sizeof(tn_package_name_structb_t), error));
  object->strprop = NULL;
  object->v5 = NULL;
  return tn_package_name_structb_init(object);
}

static void 
tn_package_name_structa_destroy(tn_object_t *object)
{
  tn_package_name_structa_t *self = (tn_package_name_structa_t*) object;
  if (self->strprop != NULL) {
    tn_object_destroy(self->strprop);
    self->strprop = NULL;
  }
  if (self->structprop != NULL) {
    tn_object_destroy(self->structprop);
    self->structprop = NULL;
  }
  if (self->listprop != NULL) {
    tn_object_destroy(self->listprop);
    self->listprop = NULL;
  }
  if (self->mapprop != NULL) {
    tn_object_destroy(self->mapprop);
    self->mapprop = NULL;
  }
  if (self->table != NULL) {
    tn_object_destroy(self->table);
    self->table = NULL;
  }
  tn_free(self);
}

static void 
tn_package_name_structa_reset(tn_object_t *object)
{
  tn_package_name_structa_t *self = (tn_package_name_structa_t*) object;
  if( self->strprop != NULL ) {
    tn_object_reset(self->strprop);
  }
  if( self->structprop != NULL ) {
    tn_object_reset(self->structprop);
  }
  if( self->listprop != NULL ) {
    tn_object_reset(self->listprop);
  }
  if( self->mapprop != NULL ) {
    tn_object_reset(self->mapprop);
  }
  if( self->table != NULL ) {
    tn_object_reset(self->table);
  }
}

/* reads a structa object */
static size_t
tn_package_name_structa_read (void *data, tn_protocol_t *protocol, tn_transport_t *transport, tn_error_t *error)
{
  int32_t size = 0;
  tn_buffer_t buf;
  size_t i = 0;
  int32_t cont_size = 0;
  tn_type_t value_type;
  tn_type_t key_type;
  tn_map_elem_t *e;
  size_t ret = 0;
  tn_type_t ftype;
  int16_t fid;
  tn_package_name_structa_t *self = (tn_package_name_structa_t*) data;
  tn_package_name_structa_reset((tn_object_t*) self);
  return_if_fail_or_inc(ret, protocol->tn_read_struct_begin(protocol, transport, error));
  while (1) {
    return_if_fail_or_inc(ret, protocol->tn_read_field_begin(protocol, transport, NULL, &ftype, &fid, error));
    if( ftype == T_STOP ) {
      break;
    }
    switch( fid ) {
      case 1:
        if (ftype == T_STRING) {
          return_if_fail_or_inc(ret, protocol->tn_read_string_begin(protocol, transport, &size, error));
          if( self->strprop == NULL ) { 
            return_if_fail(ret, self->strprop = tn_buffer_create(size, error));
          }
          return_if_fail_or_inc(ret, protocol->tn_read_string(protocol, transport, self->strprop, size, error));
          return_if_fail_or_inc(ret, protocol->tn_read_string_end(protocol, transport, error));
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 2:
        if (ftype == T_STRUCT) {
          if( self->structprop == NULL ) {
            return_if_fail(ret, self->structprop = tn_package_name_structb_create(error));
          }
          return_if_fail_or_inc(ret, tn_struct_read(self->structprop, protocol, transport, error));
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 3:
        if (ftype == T_LIST) {
          return_if_fail_or_inc(ret, protocol->tn_read_list_begin(protocol, transport, &value_type, &cont_size, error));
          if( cont_size > 0 ) {
            if( value_type == T_I32 ) {
              int32_t *v0;
              if( self->listprop == NULL ) {
                return_if_fail(ret, self->listprop = tn_list_create(sizeof(int32_t), cont_size, T_I32, error));
                return_if_fail(ret, tn_list_ensure_cap(self->listprop, cont_size, error));
              }
              if( protocol->block_container_io ) {
                buf.pos = 0;
                buf.buf = self->listprop->data;
                buf.len = cont_size * self->listprop->elem_size;
                return_if_fail_or_inc(ret, protocol->tn_read_bytes(protocol, transport, &buf, buf.len, error));
                self->listprop->elem_count = cont_size;
              } else {
                do {
                  return_if_fail(ret, v0 = tn_list_append(self->listprop, error));
                  return_if_fail_or_inc(ret, protocol->tn_read_int32(protocol, transport, v0, error));
                } while(--cont_size);
              }
            } else {
              do {
                return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, value_type, error));
              } while(--cont_size);
            }
          }
          return_if_fail_or_inc(ret, protocol->tn_read_list_end(protocol, transport, error));
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 4:
        if (ftype == T_MAP) {
          return_if_fail_or_inc(ret, protocol->tn_read_map_begin(protocol, transport, &key_type, &value_type, &cont_size, error));
          if( cont_size > 0 ) {
            if( key_type == T_I16 && value_type == T_I16 ) {
              if( self->mapprop == NULL ) {
                return_if_fail(ret, self->mapprop = tn_map_create(sizeof(int16_t), sizeof(int16_t), T_I16, T_I16, cont_size, error));
              }
              return_if_fail(ret, tn_list_ensure_cap(self->mapprop->kvs, cont_size, error));
              if( protocol->block_container_io ) {
                buf.pos = 0;
                buf.buf = self->mapprop->kvs->data;
                buf.len = cont_size * self->mapprop->kvs->elem_size;
                return_if_fail_or_inc(ret, protocol->tn_read_bytes(protocol, transport, &buf, buf.len, error));
                self->mapprop->kvs->elem_count = cont_size;
                return_if_fail(ret, tn_map_rebuild(self->mapprop, error));
              } else {
                do {
                  return_if_fail(ret, e = tn_map_append(self->mapprop, error));
                  return_if_fail_or_inc(ret, protocol->tn_read_int16(protocol, transport, ((int16_t*)e->key), error));
                  return_if_fail_or_inc(ret, protocol->tn_read_int16(protocol, transport, ((int16_t*)e->value), error));
                  tn_map_put(self->mapprop, e);
                } while(--cont_size);
              }
            } else {
              do {
                return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, key_type, error));
                return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, value_type, error));
              } while(--cont_size);
            }
          }
          return_if_fail_or_inc(ret, protocol->tn_read_map_end(protocol, transport, error));
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      case 5:
        if (ftype == T_MAP) {
          return_if_fail_or_inc(ret, protocol->tn_read_map_begin(protocol, transport, &key_type, &value_type, &cont_size, error));
          if( cont_size > 0 ) {
            if( key_type == T_STRING && value_type == T_STRING ) {
              if( self->table == NULL ) {
                return_if_fail(ret, self->table = tn_map_create(sizeof(tn_buffer_t *), sizeof(tn_buffer_t *), T_STRING, T_STRING, cont_size, error));
              }
              return_if_fail(ret, tn_list_ensure_cap(self->table->kvs, cont_size, error));
              do {
                return_if_fail(ret, e = tn_map_append(self->table, error));
                return_if_fail_or_inc(ret, protocol->tn_read_string_begin(protocol, transport, &size, error));
                if( (*(tn_buffer_t **)e->key) == NULL ) { 
                  return_if_fail(ret, (*(tn_buffer_t **)e->key) = tn_buffer_create(size, error));
                }
                return_if_fail_or_inc(ret, protocol->tn_read_string(protocol, transport, (*(tn_buffer_t **)e->key), size, error));
                return_if_fail_or_inc(ret, protocol->tn_read_string_end(protocol, transport, error));
                return_if_fail_or_inc(ret, protocol->tn_read_string_begin(protocol, transport, &size, error));
                if( (*(tn_buffer_t **)e->value) == NULL ) { 
                  return_if_fail(ret, (*(tn_buffer_t **)e->value) = tn_buffer_create(size, error));
                }
                return_if_fail_or_inc(ret, protocol->tn_read_string(protocol, transport, (*(tn_buffer_t **)e->value), size, error));
                return_if_fail_or_inc(ret, protocol->tn_read_string_end(protocol, transport, error));
                tn_map_put(self->table, e);
              } while(--cont_size);
            } else {
              do {
                return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, key_type, error));
                return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, value_type, error));
              } while(--cont_size);
            }
          }
          return_if_fail_or_inc(ret, protocol->tn_read_map_end(protocol, transport, error));
        } else {
          return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        }
        break;
      default:
        return_if_fail_or_inc(ret, tn_protocol_skip(protocol, transport, ftype, error));
        break;
    }
    return_if_fail_or_inc(ret, protocol->tn_read_field_end(protocol, transport, error));
  }
  return_if_fail_or_inc(ret, protocol->tn_read_struct_end(protocol, transport, error));
  return ret;
}

static size_t
tn_package_name_structa_write (void *data, tn_protocol_t *protocol, tn_transport_t *transport, tn_error_t *error)
{
  tn_buffer_t buf;
  size_t i = 0;
  size_t size = 0;
  tn_type_t value_type;
  tn_type_t key_type;
  tn_map_elem_t *e;
  size_t ret = 0;

  tn_package_name_structa_t *self = (tn_package_name_structa_t*) data;
  return_if_fail_or_inc(ret, protocol->tn_write_struct_begin(protocol, transport, data, error));
  
  if( self->strprop != NULL ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "strprop", T_STRING, 1, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string_begin(protocol, transport, self->strprop->pos, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string(protocol, transport, self->strprop, error));
    return_if_fail_or_inc(ret, protocol->tn_write_string_end(protocol, transport, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->structprop != NULL ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "structprop", T_STRUCT, 2, error));
    return_if_fail_or_inc(ret, tn_struct_write(self->structprop, protocol, transport, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->listprop != NULL ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "listprop", T_LIST, 3, error));
    return_if_fail_or_inc(ret, protocol->tn_write_list_begin(protocol, transport, self->listprop, error));
    int32_t *v1;
    size = self->listprop->elem_count;
    if( protocol->block_container_io ) {
      buf.buf = self->listprop->data;
      buf.len = buf.pos = size * self->listprop->elem_size;
      return_if_fail_or_inc(ret, protocol->tn_write_bytes(protocol, transport, &buf, error));
    } else {
      for(i = 0; i < size; i++) {
        v1 = tn_list_get(self->listprop,i);
        return_if_fail_or_inc(ret, protocol->tn_write_int32(protocol, transport, (*v1), error));
      }
    }
    return_if_fail_or_inc(ret, protocol->tn_write_list_end(protocol, transport, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->mapprop != NULL ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "mapprop", T_MAP, 4, error));
    return_if_fail_or_inc(ret, protocol->tn_write_map_begin(protocol, transport, self->mapprop, error));
    size = self->mapprop->kvs->elem_count;
    if( protocol->block_container_io ) {
      buf.buf = self->mapprop->kvs->data;
      buf.len = buf.pos = size * self->mapprop->kvs->elem_size;
      return_if_fail_or_inc(ret, protocol->tn_write_bytes(protocol, transport, &buf, error));
    } else {
      for(i = 0; i < size; i++) {
        e = tn_map_get(self->mapprop,i);
        return_if_fail_or_inc(ret, protocol->tn_write_int16(protocol, transport, (*(int16_t*) e->key), error));
        return_if_fail_or_inc(ret, protocol->tn_write_int16(protocol, transport, (*(int16_t*) e->value), error));
      }
    }
    return_if_fail_or_inc(ret, protocol->tn_write_map_end(protocol, transport, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  if( self->table != NULL ) {
    return_if_fail_or_inc(ret, protocol->tn_write_field_begin (protocol, transport, "table", T_MAP, 5, error));
    return_if_fail_or_inc(ret, protocol->tn_write_map_begin(protocol, transport, self->table, error));
    size = self->table->kvs->elem_count;
    for(i = 0; i < size; i++) {
      e = tn_map_get(self->table,i);
      return_if_fail_or_inc(ret, protocol->tn_write_string_begin(protocol, transport, (*(tn_buffer_t **) e->key)->pos, error));
      return_if_fail_or_inc(ret, protocol->tn_write_string(protocol, transport, (*(tn_buffer_t **) e->key), error));
      return_if_fail_or_inc(ret, protocol->tn_write_string_end(protocol, transport, error));
      return_if_fail_or_inc(ret, protocol->tn_write_string_begin(protocol, transport, (*(tn_buffer_t **) e->value)->pos, error));
      return_if_fail_or_inc(ret, protocol->tn_write_string(protocol, transport, (*(tn_buffer_t **) e->value), error));
      return_if_fail_or_inc(ret, protocol->tn_write_string_end(protocol, transport, error));
    }
    return_if_fail_or_inc(ret, protocol->tn_write_map_end(protocol, transport, error));
    return_if_fail_or_inc(ret, protocol->tn_write_field_end (protocol, transport, error));
  }
  
  return_if_fail_or_inc(ret, protocol->tn_write_field_stop (protocol, transport, error));
  return_if_fail_or_inc(ret, protocol->tn_write_struct_end (protocol, transport, error));
  return ret;
}

tn_package_name_structa_t* 
tn_package_name_structa_init (tn_package_name_structa_t *self)
{
  self->parent.parent.tn_destroy = &tn_package_name_structa_destroy;
  self->parent.parent.tn_reset = &tn_package_name_structa_reset;
  self->parent.tn_write = &tn_package_name_structa_write;
  self->parent.tn_read = &tn_package_name_structa_read;
  tn_package_name_structa_reset((tn_object_t*) self);
  return self;
}

tn_package_name_structa_t* 
tn_package_name_structa_create(tn_error_t *error)
{
  tn_package_name_structa_t *object = NULL;
  return_if_fail(object, object = tn_alloc(sizeof(tn_package_name_structa_t), error));
  object->strprop = NULL;
  object->structprop = NULL;
  object->listprop = NULL;
  object->mapprop = NULL;
  object->table = NULL;
  return tn_package_name_structa_init(object);
}

/* constants */

